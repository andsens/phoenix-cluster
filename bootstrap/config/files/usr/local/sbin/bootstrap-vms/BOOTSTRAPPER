#!/usr/bin/env bash
set -eo pipefail; shopt -s inherit_errexit

# shellcheck source=../../../../../../../.upkg/orbit-online/records.sh/records.sh
source "/usr/local/lib/upkg/orbit-online/records.sh/records.sh"

main() {
  DOC="bootstrap-vms - Bootstrap multiple VMs
Usage:
  bootstrap-vms [HOSTNAMES...]
"
# docopt parser below, refresh this parser with `docopt.sh BOOTSTRAPPER`
# shellcheck disable=2016,1090,1091,2034,2154
docopt() {
source "/usr/local/lib/upkg/andsens/docopt.sh/docopt-lib.sh" '1.0.0' || { ret=$?
printf -- "exit %d\n" "$ret"; exit "$ret"; }; set -e; trimmed_doc=${DOC:0:76}
usage=${DOC:39:37}; digest=d4a08; shorts=(); longs=(); argcounts=(); node_0(){
value HOSTNAMES a true; }; node_1(){ oneormore 0; }; node_2(){ optional 1; }
node_3(){ required 2; }; node_4(){ required 3; }; cat <<<' docopt_exit() {
[[ -n $1 ]] && printf "%s\n" "$1" >&2; printf "%s\n" "${DOC:39:37}" >&2; exit 1
}'; unset var_HOSTNAMES; parse 4 "$@"; local prefix=${DOCOPT_PREFIX:-''}
unset "${prefix}HOSTNAMES"; if declare -p var_HOSTNAMES >/dev/null 2>&1; then
eval "${prefix}"'HOSTNAMES=("${var_HOSTNAMES[@]}")'; else
eval "${prefix}"'HOSTNAMES=()'; fi; local docopt_i=1
[[ $BASH_VERSION =~ ^4.3 ]] && docopt_i=2; for ((;docopt_i>0;docopt_i--)); do
declare -p "${prefix}HOSTNAMES"; done; }
# docopt parser above, complete command for generating this parser is `docopt.sh --library='"/usr/local/lib/upkg/andsens/docopt.sh/docopt-lib.sh"' BOOTSTRAPPER`
  eval "$(docopt "$@")"

  local nfs_path=/var/lib/bootstrapper bootstrapper_path=/var/lib/home-cluster

  # shellcheck source=../../../../../../../vars.sh
  source "$nfs_path/vars.sh"

  if [[ ${#HOSTNAMES[@]} -eq 0 ]]; then
    if [[ ! -e "$nfs_path/bootstrap-vms.args.sh" ]]; then
      info "$nfs_path/bootstrap-vms.args.sh does not exist (and no hostnames provided on commandline), exiting"
      return 0
    fi
  fi
  # shellcheck disable=1091
  source "$nfs_path/bootstrap-vms.args.sh"
  ! ${SHUTDOWN:-false} || trap "systemctl halt" EXIT
  info "Updating bootstrapper code"
  rm -rf "$bootstrapper_path"
  if [[ -n $BOOTSTRAPPER_GIT_DEPLOY_KEY ]]; then
    eval "$(ssh-agent)" >&2
    ssh-add -q <(cat <<EOF
${BOOTSTRAPPER_GIT_DEPLOY_KEY}
EOF
  )
  fi
  git clone --depth 1 "$BOOTSTRAPPER_GIT_REMOTE" "$bootstrapper_path"
  if [[ -n $BOOTSTRAPPER_GIT_DEPLOY_KEY ]]; then
    ssh-add -qD
    eval "$(ssh-agent -k)" >&2
  fi

  (cd "$bootstrapper_path" && upkg install)

  local hostname ret=0
  for hostname in "${HOSTNAMES[@]}"; do
    info "Bootstrapping %s" "$hostname"
    if "$bootstrapper_path/bootstrap.sh" create \
      --varspath=$nfs_path/vars.sh \
      --cachepath="/var/lib/persistent/cache" \
      "$hostname" "$nfs_path/images/$hostname.tmp.raw"; then
      info "Successfully to bootstrapped %s" "$hostname"
      mv "$nfs_path/images/$hostname.tmp.raw" "$nfs_path/images/$hostname.latest.raw"
    else
      error "Failed to bootstrap %s" "$hostname"
      rm -f "$nfs_path/images/$hostname.tmp.raw"
      ret=1
    fi
  done
  return $ret
}

main "$@"
