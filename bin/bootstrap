#!/usr/bin/env bash
# shellcheck source-path=../
set -Eeo pipefail; shopt -s inherit_errexit
PKGROOT=$(realpath "$(dirname "$(realpath "${BASH_SOURCE[0]}")")/..")

main() {
  source "$PKGROOT/lib/common.sh"

  DOC="bootstrap - Bootstrap images
Usage:
  bootstrap [MACHINE...]
"
# docopt parser below, refresh this parser with `docopt.sh bootstrap`
# shellcheck disable=2016,1090,1091,2034,2154
docopt() { source "$PKGROOT/.upkg/andsens/docopt.sh/docopt-lib.sh" '1.0.0' || {
ret=$?; printf -- "exit %d\n" "$ret"; exit "$ret"; }; set -e
trimmed_doc=${DOC:0:70}; usage=${DOC:29:41}; digest=668e8; shorts=(); longs=()
argcounts=(); node_0(){ value MACHINE a true; }; node_1(){ optional ; }
node_2(){ optional 1; }; node_3(){ oneormore 0; }; node_4(){ optional 3; }
node_5(){ required 2 4; }; node_6(){ required 5; }; cat <<<' docopt_exit() {
[[ -n $1 ]] && printf "%s\n" "$1" >&2; printf "%s\n" "${DOC:29:41}" >&2; exit 1
}'; unset var_MACHINE; parse 6 "$@"; local prefix=${DOCOPT_PREFIX:-''}
unset "${prefix}MACHINE"; if declare -p var_MACHINE >/dev/null 2>&1; then
eval "${prefix}"'MACHINE=("${var_MACHINE[@]}")'; else
eval "${prefix}"'MACHINE=()'; fi; local docopt_i=1
[[ $BASH_VERSION =~ ^4.3 ]] && docopt_i=2; for ((;docopt_i>0;docopt_i--)); do
declare -p "${prefix}MACHINE"; done; }
# docopt parser above, complete command for generating this parser is `docopt.sh --library='"$PKGROOT/.upkg/andsens/docopt.sh/docopt-lib.sh"' bootstrap`
  eval "$(docopt "$@")"
  confirm_machine_id bootstrapper
  if [[ $UID != 0 ]]; then
    export HOME_CLUSTER_IGNORE_MACHINE_ID=true
    exec sudo "${BASH_SOURCE[0]}" "$@"
  fi

  # shellcheck disable=2153
  if [[ ${#MACHINE[@]} -eq 0 ]]; then
    if [[ ! -e "$PKGROOT/bootstrap.args.sh" ]]; then
      info "$PKGROOT/bootstrap.args.sh does not exist (and no machine names provided on commandline), exiting"
      return 0
    else
      info "bootstrp-vms.args.sh found"
      # shellcheck disable=1091
      source "$PKGROOT/bootstrap.args.sh"
      # shellcheck disable=2064
      trap "rm \"$PKGROOT/bootstrap.args.sh\"" EXIT
    fi
  fi

  local machine ret=0 cur_ret
  for machine in "${MACHINE[@]}"; do
    info "Bootstrapping %s" "$machine"
    cur_ret=0
    set +e; (set -e; bootstrap "$machine"); cur_ret=$?; set -e
    if [[ $cur_ret -eq 0 ]]; then
      info "Successfully bootstrapped %s" "$machine"
    else
      error "Failed to bootstrap %s" "$machine"
      rm -f "$PKGROOT/images/$machine.raw"
      ret=1
    fi
  done
  return $ret
}

bootstrap() {
  local machine=$1
  local imgpath=$PKGROOT/images/$machine.raw cachepath=/var/lib/persistent/cache
  [[ -e $(dirname "$cachepath") ]] || cachepath=$PKGROOT/cache
  mkdir -p "$PKGROOT/images" "$PKGROOT/logs" "$cachepath"

  if ! is_machine_id bootstrapper; then
    [[ -L "$PKGROOT/logs/fai" ]] || ln -s "/var/log/fai" "$PKGROOT/logs/fai"
  else
    rm -rf "$PKGROOT/logs/fai"
    ln -s "$PKGROOT/logs/fai" "/var/log/fai"
  fi
  # shellcheck disable=SC2086
  env - \
    "PATH=$PATH" \
    "PKGROOT=$PKGROOT" \
    "CACHEPATH=$cachepath" \
    fai-diskimage --cspace "$PKGROOT/bootstrap" --new --size "$(get_setting "machines[\"$machine\"].diskSize")" --hostname "$machine" "$imgpath"
  local convert_to_vhdx=false is_wsl=false
  ! yq -re ".machines[\"$machine\"].faiClasses[] | select(.==\"HYPERV\")" "$PKGROOT/config/home-cluster.yaml" >/dev/null || convert_to_vhdx=true
  if yq -re ".machines[\"$machine\"].faiClasses[] | select(.==\"WSL\")" "$PKGROOT/config/home-cluster.yaml" >/dev/null; then
    convert_to_vhdx=true
    is_wsl=true
  fi
  if $convert_to_vhdx; then
    if $is_wsl; then
      info "Converting partitioned raw image to unpartitioned vhdx"
    else
      info "Converting partitioned raw image to vhdx"
    fi
    local img_basepath img_sourcepath loop_path
    img_basepath=$(dirname "$imgpath")/$(basename "$imgpath" .raw)
    if $is_wsl; then
      img_sourcepath=$img_basepath.unpartitioned.raw
      loop_path=$(losetup --show --find --partscan "$imgpath")
      # shellcheck disable=SC2064
      trap "losetup --detach \"$loop_path\"; rm \"$img_basepath.unpartitioned.raw\"" EXIT
      dd if="${loop_path}p1" of="$img_basepath.unpartitioned.raw"
    else
      img_sourcepath=$img_basepath.raw
    fi
    qemuimg convert -p -f raw -O vhdx -o subformat=dynamic "$img_sourcepath" "$img_basepath.vhdx"
    imgpath=$img_basepath.vhdx
  fi
  chown "$(stat -c %u:%g "$(dirname "$imgpath")")" "$imgpath"
  if [[ $cachepath = "$PKGROOT"/* ]]; then
    chown -R "$(stat -c %u:%g "$(dirname "$cachepath")")" "$cachepath"
  fi
}

main "$@"
