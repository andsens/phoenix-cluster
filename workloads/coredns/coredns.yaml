---
apiVersion: cilium.io/v2
kind: CiliumNetworkPolicy
metadata:
  name: coredns
  labels:
    k8s-app: kube-dns
spec:
  endpointSelector:
    matchLabels:
      k8s-app: kube-dns
  ingress:
  - toPorts:
    - ports:
      - port: "53"
        protocol: TCP
      - port: "53"
        protocol: UDP
    fromEntities:
    - cluster
  - toPorts:
    - ports:
      - port: "5353"
        protocol: TCP
      - port: "5353"
        protocol: UDP
    fromEntities:
    - world
  egress:
  - toPorts:
    - ports:
      - port: "53"
        protocol: UDP
      - port: "53"
        protocol: TCP
    toEntities:
    - world
  - toPorts:
    - ports:
      - port: "2379"
    toEndpoints:
    - matchLabels:
        "k8s:io.kubernetes.pod.namespace": etcd
        app.kubernetes.io/name: etcd
        app.kubernetes.io/component: etcd
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: coredns
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: system:coredns
  labels:
    kubernetes.io/bootstrapping: rbac-defaults
rules:
- apiGroups: [""]
  resources: [endpoints, services, pods, namespaces]
  verbs: [list, watch]
- apiGroups: [discovery.k8s.io]
  resources: [endpointslices]
  verbs: [list, watch]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: system:coredns
  labels:
    kubernetes.io/bootstrapping: rbac-defaults
  annotations:
    rbac.authorization.kubernetes.io/autoupdate: "true"
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: system:coredns
subjects:
- kind: ServiceAccount
  name: coredns
  namespace: kube-system
---
apiVersion: v1
kind: Service
metadata:
  name: kube-dns
  labels:
    k8s-app: kube-dns
    kubernetes.io/name: CoreDNS
    kubernetes.io/cluster-service: "true"
spec:
  selector:
    k8s-app: kube-dns
  ipFamilyPolicy: RequireDualStack
  clusterIP: cluster.coredns.svc.fixedIP
  clusterIPs:
  - cluster.coredns.svc.fixedIPv4
  - cluster.coredns.svc.fixedIPv6
  ports:
  - name: dns
    port: 53
    protocol: UDP
  - name: dns-tcp
    port: 53
    protocol: TCP
---
apiVersion: v1
kind: Service
metadata:
  name: external-dns
  labels:
    app.kubernetes.io/name: coredns
    app.kubernetes.io/component: coredns
  annotations:
    io.cilium/lb-ipam-ips: "cluster.smallstep.fixedIPv4,cluster.smallstep.fixedIPv6"
    external-dns.alpha.kubernetes.io/hostname: ns1.DOMAIN.
spec:
  type: LoadBalancer
  ipFamilies: [IPv4, IPv6]
  ipFamilyPolicy: RequireDualStack
  selector:
    k8s-app: kube-dns
  ports:
  - name: dns
    port: 53
    targetPort: 5353
    protocol: UDP
  - name: dns-tcp
    port: 53
    targetPort: 5353
    protocol: TCP
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: coredns
  labels:
    k8s-app: kube-dns
    kubernetes.io/name: CoreDNS
    app.kubernetes.io/name: coredns
    app.kubernetes.io/component: coredns
spec:
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxUnavailable: 1
  selector:
    matchLabels:
      k8s-app: kube-dns
  template:
    metadata:
      labels:
        k8s-app: kube-dns
    spec:
      priorityClassName: system-cluster-critical
      serviceAccountName: coredns
      tolerations:
      - key: CriticalAddonsOnly
        operator: Exists
      - key: node-role.kubernetes.io/control-plane
        operator: Exists
        effect: NoSchedule
      - key: node-role.kubernetes.io/master
        operator: Exists
        effect: NoSchedule
      nodeSelector:
        kubernetes.io/os: linux
      topologySpreadConstraints:
      - maxSkew: 1
        topologyKey: kubernetes.io/hostname
        whenUnsatisfiable: DoNotSchedule
        labelSelector:
          matchLabels:
            k8s-app: kube-dns
      dnsPolicy: Default
      containers:
      - name: coredns
        args: [-conf, /etc/coredns/Corefile]
        image: coredns/coredns:1.11.1
        securityContext:
          allowPrivilegeEscalation: false
          capabilities:
            add:
            - NET_BIND_SERVICE
            drop:
            - all
          readOnlyRootFilesystem: true
        env:
        - name: CLUSTER_WANIPV4
          value: cluster.wanIPv4
        - name: CLUSTER_DOMAIN
          value: cluster.domain
        # Since coredns is scheduled on "node-role.kubernetes.io/control-plane"
        # the kube-apiserver is also available on this node, so we can use the IP from the status field
        - name: KUBE_APISERVER_IPV4
          valueFrom:
            fieldRef:
              fieldPath: status.hostIP
        # This one is bogus. We need to be able to do a little preprocessing on status.hostIPs
        # But without embedding a script during startup I'm not sure how...
        - name: KUBE_APISERVER_IPV6
          valueFrom:
            fieldRef:
              fieldPath: status.hostIP
        - name: CLUSTER_ETCD_FIXEDIPV4
          value: cluster.etcd.fixedIPv4
        - name: CLUSTER_ETCD_FIXEDIPV6
          value: cluster.etcd.fixedIPv6
        ports:
        - containerPort: 53
          name: dns
          protocol: UDP
        - containerPort: 53
          name: dns-tcp
          protocol: TCP
        - name: dns-ext
          containerPort: 5353
          protocol: UDP
        - name: dns-tcp-ext
          containerPort: 5353
          protocol: TCP
        resources:
          limits:
            memory: 170Mi
          requests:
            cpu: 100m
            memory: 70Mi
        livenessProbe:
          httpGet:
            path: /health
            port: 8080
            scheme: HTTP
          initialDelaySeconds: 60
          periodSeconds: 10
          timeoutSeconds: 1
          successThreshold: 1
          failureThreshold: 3
        readinessProbe:
          httpGet:
            path: /ready
            port: 8181
            scheme: HTTP
          initialDelaySeconds: 0
          periodSeconds: 2
          timeoutSeconds: 1
          successThreshold: 1
          failureThreshold: 3
        volumeMounts:
        - name: config
          mountPath: /etc/coredns
      volumes:
      - name: config
        configMap:
          name: coredns
