#!/usr/bin/env bash
# shellcheck source-path=../../..
set -Eeo pipefail; shopt -s inherit_errexit
PKGROOT=$(realpath "$(dirname "$(realpath "${BASH_SOURCE[0]}")")/../../..")
export DOCKER_CLI_HINTS=false

main() {
  source "$PKGROOT/.upkg/records.sh/records.sh"
  source "$PKGROOT/.upkg/path-tools/path-tools.sh"
  source "$PKGROOT/.upkg/bgpid/bgpid.sh"
  source "$PKGROOT/.upkg/trap.sh/trap.sh"
  PATH=$(path_prepend "$PKGROOT/.upkg/.bin")
  # shellcheck source=workloads/settings/env/settings.shellcheck.sh
  source "$PKGROOT/workloads/settings/env/settings.sh"
  eval_settings

  DOC="boot-server - Run the boot-server locally (untested)
Usage:
  boot-server
"
# docopt parser below, refresh this parser with `docopt.sh boot-server`
# shellcheck disable=2016,2086,2317,1090,1091,2034
docopt() { local v='2.0.1'; source \
"$PKGROOT/.upkg/docopt-lib-v$v/docopt-lib.sh" "$v" || { ret=$?;printf -- "exit \
%d\n" "$ret";exit "$ret";};set -e;trimmed_doc=${DOC:0:73};usage=${DOC:53:20}
digest=6f317;options=();node_0(){ return 0;};cat <<<' docopt_exit() { [[ -n $1 \
]] && printf "%s\n" "$1" >&2;printf "%s\n" "${DOC:53:20}" >&2;exit 1;}';local \
varnames=() varname;for varname in "${varnames[@]}"; do unset "var_$varname"
done;parse 0 "$@";return 0;local p=${DOCOPT_PREFIX:-''};for varname in \
"${varnames[@]}"; do unset "$p$varname";done;eval ;local docopt_i=1;[[ \
$BASH_VERSION =~ ^4.3 ]] && docopt_i=2;for ((;docopt_i>0;docopt_i--)); do for \
varname in "${varnames[@]}"; do declare -p "$p$varname";done;done;}
# docopt parser above, complete command for generating this parser is `docopt.sh --library='"$PKGROOT/.upkg/docopt-lib-v$v/docopt-lib.sh"' boot-server`
  eval "$(docopt "$@")"

  failures=''
  [[ $EUID = 0 ]] || failures="* Must be root to run\n"
  checkdeps in.tftpd tcpdump python3 &>/dev/null || failures="* tftpd-hpa, tcpdump, and python3 must be installed\n"

  export STEPPATH=$PKGROOT/.step
  [[ -e $STEPPATH ]] || failures="* PKI not initialized. Run \`bin/certs init\`\n"

  [[ -z $failures ]] || fatal "The following checks failed:\n%s" "$failures"

  local selected_addr
  selected_addr=$(select_addr)

  local ifname
  ifname=$(jq -re '.if.ifname' <<<"$selected_addr")
  export HOST_IP TFTP_SERVER_IP
  HOST_IP=$(jq -re '.addr.local' <<<"$selected_addr")
  TFTP_SERVER_IP=$HOST_IP

  INTERMEDIATE_CRT=$STEPPATH/certs/intermediate_ca.crt
  INTERMEDIATE_KEY=$STEPPATH/secrets/intermediate_ca_key
  TLS_CRT=$STEPPATH/certs/boot-server.crt
  TLS_KEY=$STEPPATH/certs/boot-server.key
  if [[ ! -e $TLS_KEY ]] || \
        ! step certificate verify "$TLS_CRT" --roots="$INTERMEDIATE_CRT" &>/dev/null || \
          step certificate needs-renewal "$TLS_CRT" &>/dev/null; then
    step certificate create \
      --ca "$INTERMEDIATE_CRT" --ca-key "$INTERMEDIATE_KEY" \
      --no-password --insecure \
      "$HOST_IP" "$TLS_CRT" "$TLS_KEY"
    chown "$SUDO_UID:$SUDO_UID" "$TLS_CRT" "$TLS_KEY"
  fi

  local \
    boot_server_root=$PKGROOT/mnt/boot-server \
    boot_server_venv=$PKGROOT/.venv/boot-server
  mkdir -p "$boot_server_root/images" "$boot_server_venv"

  rm -rf "$boot_server_root/node-config"
  mkdir "$boot_server_root/node-config"
  local node mac
  for node in $(yq -c '.nodes[]' "$PKGROOT/settings.yaml"); do
    ! mac=$(yq -re '.mac' <<<"$node") || \
      printf "%s\n" "$node" > "$boot_server_root/node-config/${mac//:/-}.json"
  done

  mount --bind "$PKGROOT/images" "$boot_server_root/images"
  trap_append "umount \"$boot_server_root/images\"" EXIT

  trap_prepend "bg_killall" TERM
  trap_prepend "bg_killall" INT
  trap_prepend "bg_killall" EXIT

  python3 -m venv "$boot_server_venv"
  "$boot_server_venv/bin/pip3" install -r "$PKGROOT/workloads/node/containers/dhcp-proxy/requirements.txt"

  bg_run "$boot_server_venv/bin/python3" "$PKGROOT/workloads/node/scripts/dhcp-proxy.py" \
    --boot-map "$PKGROOT/workloads/node/config/boot-map.yaml" "$HOST_IP" "$TFTP_SERVER_IP"
  bg_run in.tftpd \
    --foreground --user tftp --address "$HOST_IP:69" \
    --map-file "$PKGROOT/workloads/node/config/tftpd-map-file" --secure "$boot_server_root" --blocksize 1468
  bg_run "$boot_server_venv/bin/python3" "$PKGROOT/workloads/node/scripts/httpd.py" \
    --tls-bundle <(step certificate bundle --force "$TLS_CRT" "$INTERMEDIATE_CRT" /dev/stdout) \
    --tls-key "$TLS_KEY" \
    "$HOST_IP" "$boot_server_root"
  bg_run tcpdump -i "$ifname" -nl port 69 and udp
  info "boot-server is ready"
  bg_block
}

select_addr() {
  local addrs=() addr_count selected_addr
  readarray -t -d $'\n' addrs < <(ip --json a | jq -c '.[] | select(.ifname!="lo") | . as $if | .addr_info[] | {"if":$if,"addr":.}')
  addr_count=${#addrs[@]}
  if [[ $addr_count -eq 0 ]]; then
    fatal 'Unable to find any networks'
  elif [[ $addr_count -gt 1 ]]; then
    info 'Found multiple networks, please select:'
    local addr_idx=1 addr_json
    for addr_json in "${addrs[@]}"; do
      printf "[%d] %s: %s\n" $(( addr_idx++ )) "$(jq -r '.if.ifname' <<<"$addr_json")" "$(jq -r '.addr.local' <<<"$addr_json")" >&2
    done
    local selected_addr_idx
    while [[ -z $selected_addr ]]; do
      printf "address: " >&2
      read -r selected_addr_idx
      if (( selected_addr_idx > 0 && selected_addr_idx <= addr_count )); then
        selected_addr=${addrs[$((selected_addr_idx-1))]}
      else
        info "Invalid selection"
      fi
    done
  else
    selected_addr=${addrs[0]}
  fi
  printf "%s\n" "$selected_addr"
}

main "$@"
