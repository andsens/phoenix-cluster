#!/usr/bin/env bash
# shellcheck source-path=../../..
set -Eeo pipefail; shopt -s inherit_errexit
PKGROOT=$(realpath "$(dirname "$(realpath "${BASH_SOURCE[0]}")")/../../..")
export DOCKER_CLI_HINTS=false

main() {
  source "$PKGROOT/.upkg/records.sh/records.sh"
  source "$PKGROOT/.upkg/path-tools/path-tools.sh"
  source "$PKGROOT/.upkg/bgpid/bgpid.sh"
  source "$PKGROOT/.upkg/trap.sh/trap.sh"
  PATH=$(path_prepend "$PKGROOT/.upkg/.bin")
  # shellcheck source=workloads/settings/env/settings.shellcheck.sh
  source "$PKGROOT/workloads/settings/env/settings.sh"
  eval_settings

  DOC="boot-server - Run the boot-server locally (untested)
Usage:
  boot-server
"
# docopt parser below, refresh this parser with `docopt.sh boot-server`
# shellcheck disable=2016,2086,2317,1090,1091,2034
docopt() { local v='2.0.1'; source \
"$PKGROOT/.upkg/docopt-lib-v$v/docopt-lib.sh" "$v" || { ret=$?;printf -- "exit \
%d\n" "$ret";exit "$ret";};set -e;trimmed_doc=${DOC:0:73};usage=${DOC:53:20}
digest=6f317;options=();node_0(){ return 0;};cat <<<' docopt_exit() { [[ -n $1 \
]] && printf "%s\n" "$1" >&2;printf "%s\n" "${DOC:53:20}" >&2;exit 1;}';local \
varnames=() varname;for varname in "${varnames[@]}"; do unset "var_$varname"
done;parse 0 "$@";return 0;local p=${DOCOPT_PREFIX:-''};for varname in \
"${varnames[@]}"; do unset "$p$varname";done;eval ;local docopt_i=1;[[ \
$BASH_VERSION =~ ^4.3 ]] && docopt_i=2;for ((;docopt_i>0;docopt_i--)); do for \
varname in "${varnames[@]}"; do declare -p "$p$varname";done;done;}
# docopt parser above, complete command for generating this parser is `docopt.sh --library='"$PKGROOT/.upkg/docopt-lib-v$v/docopt-lib.sh"' boot-server`
  eval "$(docopt "$@")"

  [[ $EUID = 0 ]] || fatal "Must be root to run"
  checkdeps in.tftpd tcpdump python3

  local selected_addr
  selected_addr=$(select_addr)

  local ifname
  ifname=$(jq -re '.if.ifname' <<<"$selected_addr")
  export HOST_IP TFTP_SERVER_IP
  HOST_IP=$(jq -re '.addr.local' <<<"$selected_addr")
  TFTP_SERVER_IP=$HOST_IP

  local \
    boot_server_root=$PKGROOT/mnt/boot-server \
    dhcp_proxy_home=$PKGROOT/workloads/node/containers/dhcp-proxy \
    dhcp_proxy_venv=$PKGROOT/.venv/dhcp-proxy
  mkdir -p "$boot_server_root/images" "$dhcp_proxy_venv"

  rm -rf "$boot_server_root/node-settings"
  mkdir "$boot_server_root/node-settings"
  local node mac
  for node in $(yq -c '.nodes[]' "$PKGROOT/settings.yaml"); do
    ! mac=$(yq -re '.mac' <<<"$node") || \
      printf "%s\n" "$node" > "$boot_server_root/node-settings/${mac//:/-}.json"
  done

  mount --bind "$PKGROOT/images" "$boot_server_root/images"
  trap_append "umount \"$boot_server_root/images\"" EXIT

  trap_prepend "bg_killall" TERM
  trap_prepend "bg_killall" INT
  trap_prepend "bg_killall" EXIT

  python3 -m venv "$dhcp_proxy_venv"
  "$dhcp_proxy_venv/bin/pip3" install -r "$dhcp_proxy_home/requirements.txt"

  bg_run "$dhcp_proxy_venv/bin/python3" "$dhcp_proxy_home/dhcp-proxy.py" --boot-map "$dhcp_proxy_home/boot-map.yaml" "$HOST_IP" "$TFTP_SERVER_IP"
  bg_run in.tftpd --foreground --user tftp --address "$HOST_IP:69" --map-file "$PKGROOT/workloads/node/config/tftpd-map-file" --secure "$boot_server_root" --blocksize 1468
  bg_run "$dhcp_proxy_venv/bin/python3" -m http.server -d "$boot_server_root" -b "$HOST_IP" 8020
  bg_run tcpdump -i "$ifname" -nl port 69 and udp

  info "boot-server is ready"
  bg_block
}

select_addr() {
  local addrs=() addr_count selected_addr
  readarray -t -d $'\n' addrs < <(ip --json a | jq -c '.[] | select(.ifname!="lo") | . as $if | .addr_info[] | {"if":$if,"addr":.}')
  addr_count=${#addrs[@]}
  if [[ $addr_count -eq 0 ]]; then
    fatal 'Unable to find any networks'
  elif [[ $addr_count -gt 1 ]]; then
    info 'Found multiple networks, please select:'
    local addr_idx=1 addr_json
    for addr_json in "${addrs[@]}"; do
      printf "[%d] %s: %s\n" $(( addr_idx++ )) "$(jq -r '.if.ifname' <<<"$addr_json")" "$(jq -r '.addr.local' <<<"$addr_json")" >&2
    done
    local selected_addr_idx
    while [[ -z $selected_addr ]]; do
      printf "address: " >&2
      read -r selected_addr_idx
      if (( selected_addr_idx > 0 && selected_addr_idx <= addr_count )); then
        selected_addr=${addrs[$((selected_addr_idx-1))]}
      else
        info "Invalid selection"
      fi
    done
  else
    selected_addr=${addrs[0]}
  fi
  printf "%s\n" "$selected_addr"
}

main "$@"
