#!/usr/bin/env bash
# shellcheck source-path=../../..
set -Eeo pipefail; shopt -s inherit_errexit
PKGROOT=$(realpath "$(dirname "$(realpath "${BASH_SOURCE[0]}")")/../../..")

main() {
  source "$PKGROOT/.upkg/records.sh/records.sh"
  source "$PKGROOT/.upkg/path-tools/path-tools.sh"
  PATH=$(path_prepend "$PKGROOT/.upkg/.bin")
  [[ ! -r /etc/rancher/k3s/k3s.yaml ]] || export KUBECONFIG=/etc/rancher/k3s/k3s.yaml
  # shellcheck source=workloads/settings/env/settings.shellcheck.sh
  source "$PKGROOT/workloads/settings/env/settings.sh"
  eval_settings

  DOC="node - Manage kubernetes nodes and images
Usage:
  nodes list
  nodes authorize EK_HASH
  nodes revoke EK_HASH
  nodes pending del EK_HASH
"
# docopt parser below, refresh this parser with `docopt.sh nodes`
# shellcheck disable=2016,2086,2317,1090,1091,2034
docopt() { local v='2.0.2'; source \
"$PKGROOT/.upkg/docopt-lib-v$v/docopt-lib.sh" "$v" || { ret=$?;printf -- "exit \
%d\n" "$ret";exit "$ret";};set -e;trimmed_doc=${DOC:0:138};usage=${DOC:42:96}
digest=56aeb;options=();node_0(){ value EK_HASH a;};node_1(){ switch list a:list
};node_2(){ switch authorize a:authorize;};node_3(){ switch revoke a:revoke;}
node_4(){ switch pending a:pending;};node_5(){ switch del a:del;};node_6(){
sequence 2 0;};node_7(){ sequence 3 0;};node_8(){ sequence 4 5 0;};node_9(){
choice 1 6 7 8;};cat <<<' docopt_exit() { [[ -n $1 ]] && printf "%s\n" "$1" >&2
printf "%s\n" "${DOC:42:96}" >&2;exit 1;}';local varnames=(EK_HASH list \
authorize revoke pending del) varname;for varname in "${varnames[@]}"; do
unset "var_$varname";done;parse 9 "$@";local p=${DOCOPT_PREFIX:-''};for \
varname in "${varnames[@]}"; do unset "$p$varname";done;eval $p'EK_HASH=${var_'\
'EK_HASH:-};'$p'list=${var_list:-false};'$p'authorize=${var_authorize:-false};'\
$p'revoke=${var_revoke:-false};'$p'pending=${var_pending:-false};'$p'del=${var'\
'_del:-false};';local docopt_i=1;[[ $BASH_VERSION =~ ^4.3 ]] && docopt_i=2;for \
((;docopt_i>0;docopt_i--)); do for varname in "${varnames[@]}"; do declare -p \
"$p$varname";done;done;}
# docopt parser above, complete command for generating this parser is `docopt.sh --library='"$PKGROOT/.upkg/docopt-lib-v$v/docopt-lib.sh"' nodes`
  eval "$(docopt "$@")"

  # shellcheck disable=SC2154
  if ! $pending; then
    local whitelisted
    whitelisted=$(exec_server "cat /attestation-database/ek-whitelist.json" 2>/dev/null) || whitelisted='[]'
  fi
  # shellcheck disable=SC2154
  if $list || $authorize || $pending; then
    local pending_eks
    pending_eks=$(exec_server "cat /attestation-database/ek-pending.json" 2>/dev/null) || pending_eks='[]'
  fi

  # shellcheck disable=SC2154
  if $list; then
    local nodes='[]' ek_hash node status
    for node in $(kubectl get nodes -o=jsonpath='{.items[*].metadata.name}'); do
      status=$(kubectl get nodes -o=jsonpath='{.items[*].status.conditions}' | jq -r '[.[] | select(.status)] | last | .type')
      nodes=$(jq --arg node "$node" --arg status "$status" '. += [{"hostname": $node, "status": $status, "ek_hash": ""}]' <<<"$nodes")
    done
    for ek_hash in $(jq -r '.[]' <<<"$whitelisted"); do
      nodes=$(jq --arg node "$node" --arg ek_hash "$ek_hash" '. += [{"hostname": "", "status": "whitelisted", "ek_hash": $ek_hash}]' <<<"$nodes")
    done
    for ek_hash in $(jq -r '.[]' <<<"$pending_eks"); do
      nodes=$(jq --arg node "$node" --arg ek_hash "$ek_hash" '. += [{"hostname": "", "status": "pending", "ek_hash": $ek_hash}]' <<<"$nodes")
    done
    jq -r '.[] | [.hostname, .status, .ek_hash] | @tsv' <<<"$nodes" | column -ts $'\t' -n "Nodes" -N "Hostname,Status,EK Hash"
  elif $authorize; then
    # shellcheck disable=SC2153
    if ! jq -re --arg ek_hash "$EK_HASH" 'index($ek_hash)!=null' <<<"$whitelisted" &>/dev/null; then
      whitelisted=$(jq --arg ek_hash "$EK_HASH" '. += [$ek_hash]' <<<"$whitelisted")
      pending_eks=$(jq --arg ek_hash "$EK_HASH" 'del(.[(index($ek_hash))])' <<<"$pending_eks")
      exec_server "tee /attestation-database/ek-whitelist.json >/dev/null" <<<"$whitelisted"
      exec_server "tee /attestation-database/ek-pending.json >/dev/null" <<<"$pending_eks"
      info "The node with the endorsement key %s has been whitelisted" "$EK_HASH"
    else
      info "The node with the endorsement key %s is already whitelisted" "$EK_HASH"
    fi
  elif $revoke; then
    if jq -re --arg ek_hash "$EK_HASH" 'index($ek_hash)!=null' <<<"$whitelisted" &>/dev/null; then
      whitelisted=$(jq --arg ek_hash "$EK_HASH" 'del(.[(index($ek_hash))])' <<<"$whitelisted")
      exec_server "tee /attestation-database/ek-whitelist.json >/dev/null" <<<"$whitelisted"
      info "The node with the endorsement key %s has been removed from the whitelist" "$EK_HASH"
    else
      info "The node with the endorsement key %s is not whitelisted" "$EK_HASH"
    fi
  elif $pending; then
    if $del; then
      if jq -re --arg ek_hash "$EK_HASH" 'index($ek_hash)!=null' <<<"$pending_eks" &>/dev/null; then
        pending_eks=$(jq --arg ek_hash "$EK_HASH" 'del(.[(index($ek_hash))])' <<<"$pending_eks")
        exec_server "tee /attestation-database/ek-pending.json >/dev/null" <<<"$pending_eks"
        info "The node with the endorsement key %s has been removed from the pending list" "$EK_HASH"
      else
        info "The node with the endorsement key %s is not pending" "$EK_HASH"
      fi
    fi
  fi
}

exec_server() {
  kubectl exec -i -n node -c safeboot-attest boot-server-0 -- bash -c "$@"
}

kubectl() {
  KUBECONFIG=$HOME/.kube/home-cluster.yaml command kubectl --context home-cluster "$@"
}

main "$@"
