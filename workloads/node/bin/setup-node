#!/usr/bin/env bash
# shellcheck source-path=../../..
set -Eeo pipefail; shopt -s inherit_errexit
PKGROOT=$(realpath "$(dirname "$(realpath "${BASH_SOURCE[0]}")")/../../..")

main() {
  source "$PKGROOT/.upkg/records.sh/records.sh"
  source "$PKGROOT/.upkg/trap.sh/trap.sh"
  source "$PKGROOT/workloads/node/bootstrap/assets/etc/initramfs-tools/scripts/node.sh"
  source "$PKGROOT/workloads/node/bootstrap/assets/etc/initramfs-tools/scripts/disk-uuids.sh"
  source "$PKGROOT/workloads/node/bootstrap/assets/etc/initramfs-tools/scripts/curl-boot-server.sh"
  source "$PKGROOT/.upkg/path-tools/path-tools.sh"
  PATH=$(path_prepend "$PKGROOT/.upkg/.bin")

  ### Mount boot partition (maybe)
  mountpoint -q /boot || mount -t vfat PARTUUID=$BOOT_UUID /boot || true

  ### Copy/generate node key
  if [[ -e $NODE_KEY_CACHE_PATH ]]; then
    info "node-key found on boot partition"
    cp "$NODE_KEY_CACHE_PATH" "$NODE_KEY_PATH"
    set_node_state node-key.persisted true true
  else
    info "node-key not found, generating now"
    (umask 0077; openssl genrsa -out $NODE_KEY_PATH)
    set_node_state node-key.persisted false true
  fi
  openssl rsa -in $NODE_KEY_PATH -pubout -out $NODE_KEY_PATH.pub
  set_node_state node-key.public "$(cat "$NODE_KEY_PATH.pub")"

  ### Store details about blockdevices & NICs in node state
  local blockdevices='[]' devpath disk_filesystem disk_partitions
  for devpath in $(lsblk --json --output NAME,FSTYPE,TYPE,MAJ:MIN | jq -r '.blockdevices[] | select(.type=="disk" and (.["maj:min"] | endswith(":0"))) | "/dev/\(.name)"'); do
    disk_filesystem=$(lsblk -Jndo FSTYPE "$devpath" | jq '.blockdevices[0].fstype')
    disk_partitions=$(sfdisk -J "$devpath" 2>/dev/null || printf "null")
    blockdevices=$(jq --arg devpath "$devpath" --argjson fs "$disk_filesystem" --argjson part "$disk_partitions" '. + [{"devpath": $devpath, "filesystem": $fs, "partitions": $part}]' <<<"$blockdevices")
  done
  set_node_state blockdevices "$blockdevices" true
  local nics
  nics=$(ip --json link show | jq '[.[] | select(.ifname != "lo") | {"ifname": .ifname, "mac": .address}]')
  set_node_state nics "$nics" true

  ### Report node state
  report_node_state

  ### Retrieve node config from boot-server
  local encrypted_node_config node_config
  while boot_server_available || [[ ! -e $NODE_CONFIG_CACHE_PATH ]]; do
    # Keep retrying if there is no cached node config to fall back to,
    # even if the boot-server is unavailable
    if encrypted_node_config=$(download_node_config); then
      info "Node config received"
      node_config=$(decrypt_node_config "$encrypted_node_config") || fatal "Unable to decrypt node config"
      printf "%s\n" "$node_config" >$NODE_CONFIG_PATH
      break
    fi
    warning "Failed to download node config, retrying in 15s"
    sleep 15
  done

  ### Fall back to copying cached node config from boot partition
  if [[ ! -e $NODE_CONFIG_PATH ]]; then
    warning "Failed to download node config, falling back to cached version on boot partition"
    node_config=$(decrypt_node_config "$(cat $NODE_CONFIG_CACHE_PATH)")
    printf "%s\n" "$node_config" >$NODE_CONFIG_PATH
  fi

  ### Partition disk
  local devpath
  devpath=$(get_node_config disk.devpath)
  if lsblk -Jndo PTUUID "$devpath" | jq -re --arg disk_uuid $DISK_UUID '.blockdevices[0].ptuuid != $disk_uuid' &>/dev/null; then
    if sfdisk -J "$devpath" &>/dev/null || lsblk -Jndo FSTYPE "$devpath" | jq -re '.blockdevices[0].fstype != null' >/dev/null; then
      [[ $(get_node_config disk.force) = true ]] || fatal "Device %s is partitioned or contains a filesystem and .disk.force != true, aborting disk setup" "$devpath"
    fi
    info 'Partitioning disk at "%s"' "$devpath"
    wipefs -a "$devpath"
    sfdisk "$devpath" <<EOF
label: gpt
label-id: $DISK_UUID
size=1GiB, type=U, bootable, uuid=$BOOT_UUID
uuid=$DATA_UUID
EOF
    # Make sure to wipe leftover data before creating filesystems on the partitions
    local part_devname
    for part_devname in $(lsblk -Jno NAME "$devpath" | jq -re '.blockdevices[0].children[] | .name'); do
      wipefs -a "/dev/$part_devname"
    done
  fi

  ### Setup boot partition
  if lsblk -Jndo FSTYPE /dev/disk/by-partuuid/$BOOT_UUID | jq -re '.blockdevices[0].fstype != "vfat"' >/dev/null; then
    mkfs.vfat /dev/disk/by-partuuid/$BOOT_UUID
    mount -t vfat PARTUUID=$BOOT_UUID /boot
    mkdir /boot/home-cluster
  fi

  ### Cache node config
  if [[ ! -e $NODE_CONFIG_CACHE_PATH ]]; then
    info "Caching node config to %s" $NODE_CONFIG_CACHE_PATH
    printf "%s\n" "$encrypted_node_config" >$NODE_CONFIG_CACHE_PATH
  fi

  # Persist the node-key and tell the boot-server about it
  if [[ ! -e $NODE_KEY_CACHE_PATH ]]; then
    info "Caching node key to boot partition"
    cp "$NODE_KEY_PATH" "$NODE_KEY_CACHE_PATH"
    set_node_state node-key.persisted true true
  fi

  ### Setup encrypted data partition
  local disk_encryption_key_path=/run/initramfs/disk-encryption-key
  (umask 0077; get_node_config disk.encryption-key | base64 -d >$disk_encryption_key_path)
  if ! cryptsetup isLuks "/dev/disk/by-partuuid/$DATA_UUID"; then
    info "Encrypting data partition"
    cryptsetup luksFormat --batch-mode "/dev/disk/by-partuuid/$DATA_UUID" $disk_encryption_key_path
  fi

  ### Configure networking
  local network
  for network in $(jq -r '(.networks // {}) | keys[]' "$NODE_CONFIG_PATH"); do
    info 'Configuring network "%s"' "$network"
    config=$(jq -r --arg network "$network" '.networks[$network]' "$NODE_CONFIG_PATH")
    # shellcheck disable=SC2154
    printf "%s\n" "$config" >"/etc/systemd/network/$network.network"
  done

  ### Configure hostname
  local hostname primary_mac
  if hostname=$(get_node_config hostname); then
    :
  elif primary_mac=$(get_node_state primary-mac); then
    warning "No hostname defined in node-config, using primary-mac from node-state.json"
    hostname=${primary_mac//:/-}
  else
    warning "No hostname defined in node-config and primary-mac not found in node-state, generating random hostname"
    hostname=$(xxd -p -l4 /dev/random)
  fi
  info "Configuring hostname for node as %s" "$hostname"
  # shellcheck disable=SC2154
  printf "%s\n" "$hostname" >/etc/hostname
  hostname -F /etc/hostname
  set_node_state hostname "$hostname"

  ### Report node state after setup
  report_node_state
}

main "$@"
