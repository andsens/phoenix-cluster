#!/usr/bin/env bash
# shellcheck source-path=../../..
set -Eeo pipefail; shopt -s inherit_errexit
PKGROOT=$(realpath "$(dirname "$(realpath "${BASH_SOURCE[0]}")")/../../..")

main() {
  source "$PKGROOT/.upkg/records.sh/records.sh"
  source "$PKGROOT/workloads/node/bootstrap/assets/etc/initramfs-tools/scripts/disk.sh"
  source "$PKGROOT/.upkg/path-tools/path-tools.sh"
  PATH=$(path_prepend "$PKGROOT/.upkg/.bin")

  DOC="resource-ready - Determine whether a resource is ready
Usage:
  resource-ready [options] RESOURCE

Options:
  -w --wait  Block until the resource is ready

Recognized resources are:
* node-config
* disk
* boot-mount
* persistent-mount
* k3s
* cilium
* coredns
* step-ca
"
# docopt parser below, refresh this parser with `docopt.sh resource-ready`
# shellcheck disable=2016,2086,2317,1090,1091,2034
docopt() { local v='2.0.1'; source \
"$PKGROOT/.upkg/docopt-lib-v$v/docopt-lib.sh" "$v" || { ret=$?;printf -- "exit \
%d\n" "$ret";exit "$ret";};set -e;trimmed_doc=${DOC:0:250};usage=${DOC:55:42}
digest=74b51;options=('-w --wait 0');node_0(){ switch __wait 0;};node_1(){
value RESOURCE a;};node_2(){ optional 0;};node_3(){ sequence 2 1;};cat <<<' \
docopt_exit() { [[ -n $1 ]] && printf "%s\n" "$1" >&2;printf "%s\n" \
"${DOC:55:42}" >&2;exit 1;}';local varnames=(__wait RESOURCE) varname;for \
varname in "${varnames[@]}"; do unset "var_$varname";done;parse 3 "$@";local \
p=${DOCOPT_PREFIX:-''};for varname in "${varnames[@]}"; do unset "$p$varname"
done;eval $p'__wait=${var___wait:-false};'$p'RESOURCE=${var_RESOURCE:-};'
local docopt_i=1;[[ $BASH_VERSION =~ ^4.3 ]] && docopt_i=2;for \
((;docopt_i>0;docopt_i--)); do for varname in "${varnames[@]}"; do declare -p \
"$p$varname";done;done;}
# docopt parser above, complete command for generating this parser is `docopt.sh --library='"$PKGROOT/.upkg/docopt-lib-v$v/docopt-lib.sh"' resource-ready`
  eval "$(docopt "$@")"

  # shellcheck disable=SC2153
  local resource=${RESOURCE//[^A-Za-z0-9_]/_}
  type "${resource}_ready" &>/dev/null || fatal "Unknown resource: '%s'" "$RESOURCE"
  # Slightly different check than in the other scripts.
  # k3s.yaml may not have been created yet when this runs.
  # We use the presence of the k3s dir and the executing user ID as an indicator
  # as to whether k3s.yaml should be used for connecting to the cluster.
  [[ ! -e /etc/rancher/k3s && $UID != 0 ]] || export KUBECONFIG=/etc/rancher/k3s/k3s.yaml

  # shellcheck disable=SC2154
  if $__wait; then
    until eval "${resource}_ready" 2> >(pipe_verbose); do
      sleep 1
    done
    info "%s is ready" "$resource"
  else
    if eval "${resource}_ready" 2> >(pipe_verbose); then
      info "%s is ready" "$resource"
    else
      fatal $? "%s is not ready" "$resource"
    fi
  fi
}

disk_ready() {
  local devpaths=()
  if devpath=$(get_node_config disk.devpath); then
    readarray -t -d $'\n' devpaths < <(lsblk -Jndo PTUUID,NAME -a | jq -r --arg disk_uuid $DISK_UUID '.blockdevices[] | select(.ptuuid==$disk_uuid) | "/dev/\(.name)"')
    contains_element "$devpath" "${devpaths[@]}"
  else
    return 1
  fi
}

boot_mount_ready() {
  mountpoint -q /boot
}

persistent_mount_ready() {
  mountpoint -q /var/lib/persistent
}

k3s_ready() {
  kubectl get -n default endpoints kubernetes -ojsonpath='{.subsets[0].addresses}' | jq -e 'length > 0' &>/dev/null
}

cilium_ready() {
  deployment_ready kube-system cilium-operator
}

coredns_ready() {
  deployment_ready kube-system coredns
}

step_ca_ready() {
  statefulset_ready smallstep step-ca
}

deployment_ready() {
  local ns=$1 deployment=$2
  [[ $(kubectl get -n "$ns" deployment "$deployment" -ojsonpath='{.status.readyReplicas}') -gt 0 ]] || return 1
}

statefulset_ready() {
  local ns=$1 sts=$2
  [[ $(kubectl get -n "$ns" statefulset "$sts" -ojsonpath='{.status.readyReplicas}') -gt 0 ]] || return 1
}

pod_ready() {
  local ns=$1 pod=$2
  kubectl -n "$ns" get pod "$pod" -o=jsonpath='{.status.conditions}' | jq -re 'any(.[] | select(.type == "Ready"); .status == "True")' >/dev/null
}

main "$@"
