#!/usr/bin/env bash
# shellcheck source-path=../../..
set -Eeo pipefail; shopt -s inherit_errexit
PKGROOT=$(realpath "$(dirname "$(realpath "${BASH_SOURCE[0]}")")/../../..")

main() {
  source "$PKGROOT/.upkg/records.sh/records.sh"
  source "$PKGROOT/workloads/node/bootstrap/assets/etc/initramfs-tools/scripts/node.sh"
  source "$PKGROOT/workloads/node/bootstrap/assets/etc/initramfs-tools/scripts/disk.sh"

  DOC="disk - Manage the disk for persisting data
Usage:
  disk mount-boot
  disk setup
"
# docopt parser below, refresh this parser with `docopt.sh disk`
# shellcheck disable=2016,2086,2317,1090,1091,2034
docopt() { local v='2.0.1'; source \
"$PKGROOT/.upkg/docopt-lib-v$v/docopt-lib.sh" "$v" || { ret=$?;printf -- "exit \
%d\n" "$ret";exit "$ret";};set -e;trimmed_doc=${DOC:0:107};usage=${DOC:43:64}
digest=af59f;options=();node_0(){ value DEVPATH a;};node_1(){ switch \
get_devpath a:get-devpath;};node_2(){ switch mount_boot a:mount-boot;};node_3(){
switch setup a:setup;};node_4(){ sequence 3 0;};node_5(){ choice 1 2 4;};cat \
<<<' docopt_exit() { [[ -n $1 ]] && printf "%s\n" "$1" >&2;printf "%s\n" \
"${DOC:43:64}" >&2;exit 1;}';local varnames=(DEVPATH get_devpath mount_boot \
setup) varname;for varname in "${varnames[@]}"; do unset "var_$varname";done
parse 5 "$@";local p=${DOCOPT_PREFIX:-''};for varname in "${varnames[@]}"; do
unset "$p$varname";done;eval $p'DEVPATH=${var_DEVPATH:-};'$p'get_devpath=${var'\
'_get_devpath:-false};'$p'mount_boot=${var_mount_boot:-false};'$p'setup=${var_'\
'setup:-false};';local docopt_i=1;[[ $BASH_VERSION =~ ^4.3 ]] && docopt_i=2
for ((;docopt_i>0;docopt_i--)); do for varname in "${varnames[@]}"; do declare \
-p "$p$varname";done;done;}
# docopt parser above, complete command for generating this parser is `docopt.sh --library='"$PKGROOT/.upkg/docopt-lib-v$v/docopt-lib.sh"' disk`
  eval "$(docopt "$@")"

  local devpath boot_devpath

  # shellcheck disable=SC2154
  if $mount_boot; then
    devpath=$(get_node_config disk.devpath) || devpath=$(find_disk) || fatal "No initialized disk for persisting data found"
    boot_devpath=$(get_boot_devpath "$devpath")
    verbose "Mounting boot partition"
    mount "$boot_devpath" /boot
  elif $setup; then
    local devpaths=()
    devpath=$(get_node_config disk.devpath) || fatal "Unable to setup disk, no devpath provided in node-config.json"
    if lsblk -Jndo PTUUID,NAME "$devpath" | jq -re --arg disk_uuid $DISK_UUID '.blockdevices[0].ptuuid==$disk_uuid' >/dev/null; then
      info "disk at '%s' is already setup" "$devpath"
    fi
    if sfdisk -J "$devpath" 2>/dev/null || lsblk -Jndo FSTYPE "$devpath" | jq -re '.blockdevices[0].fstype != null' >/dev/null; then
      get_node_config disk.force || fatal "Device %s is partitioned or contains a filesystem and .disk.force!=true, aborting disk setup"
    fi
    wipefs -a "$devpath"
    # shellcheck disable=SC2153
    partition_disk "$devpath"
    boot_devpath=$(get_boot_devpath "$devpath")
    mkfs.vfat "$boot_devpath"
    set_node_state disk.devpath "$devpath"
  fi
}

partition_disk() {
  local devpath=$1
  ! sfdisk -J "$devpath" &>/dev/null || fatal "%s is partitioned, use \`wipefs -a\` to clear it first"
  if lsblk -Jndo FSTYPE "$devpath" | jq -re '.blockdevices[0].fstype != null' &>/dev/null; then
    fatal "%s contains a filesystem, use \`wipefs -a\` to clear it first"
  fi

  local sector_size_b sectors_per_mib
  sector_size_b=$(lsblk --json -o phy-sec "$devpath" | jq -r '.blockdevices[0]["phy-sec"]')
  sectors_per_mib=$((1024 * 1024 / sector_size_b))

  boot_partition_size_mib=1024 # 1 GiB
  sfdisk "$devpath" <<EOF
label: gpt
label-id: $DISK_UUID

start=$(( 1 * sectors_per_mib )), size=$(( boot_partition_size_mib * sectors_per_mib )), type=U, bootable, uuid=$ESP_UUID
start=$(( ( 1 + boot_partition_size_mib ) * sectors_per_mib )), uuid=$DATA_UUID
EOF
}

main "$@"
