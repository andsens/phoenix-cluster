#!/usr/bin/env bash
# shellcheck source-path=../../..
set -Eeo pipefail; shopt -s inherit_errexit
PKGROOT=$(realpath "$(dirname "$(realpath "${BASH_SOURCE[0]}")")/../../..")

main() {
  source "$PKGROOT/.upkg/records.sh/records.sh"
  source "$PKGROOT/workloads/node/bootstrap/assets/etc/initramfs-tools/scripts/node.sh"
  source "$PKGROOT/workloads/node/bootstrap/assets/etc/initramfs-tools/scripts/disk.sh"

  DOC="disk - Manage the disk for persisting data
Usage:
  disk mount-boot
  disk setup
"
# docopt parser below, refresh this parser with `docopt.sh disk`
# shellcheck disable=2016,2086,2317,1090,1091,2034
docopt() { local v='2.0.1'; source \
"$PKGROOT/.upkg/docopt-lib-v$v/docopt-lib.sh" "$v" || { ret=$?;printf -- "exit \
%d\n" "$ret";exit "$ret";};set -e;trimmed_doc=${DOC:0:80};usage=${DOC:43:37}
digest=60319;options=();node_0(){ switch mount_boot a:mount-boot;};node_1(){
switch setup a:setup;};node_2(){ choice 0 1;};cat <<<' docopt_exit() { [[ -n \
$1 ]] && printf "%s\n" "$1" >&2;printf "%s\n" "${DOC:43:37}" >&2;exit 1;}'
local varnames=(mount_boot setup) varname;for varname in "${varnames[@]}"; do
unset "var_$varname";done;parse 2 "$@";local p=${DOCOPT_PREFIX:-''};for \
varname in "${varnames[@]}"; do unset "$p$varname";done;eval $p'mount_boot=${v'\
'ar_mount_boot:-false};'$p'setup=${var_setup:-false};';local docopt_i=1;[[ \
$BASH_VERSION =~ ^4.3 ]] && docopt_i=2;for ((;docopt_i>0;docopt_i--)); do for \
varname in "${varnames[@]}"; do declare -p "$p$varname";done;done;}
# docopt parser above, complete command for generating this parser is `docopt.sh --library='"$PKGROOT/.upkg/docopt-lib-v$v/docopt-lib.sh"' disk`
  eval "$(docopt "$@")"

  local devpath boot_devpath

  # shellcheck disable=SC2154
  if $mount_boot; then
    devpath=$(get_node_config disk.devpath) || devpath=$(find_disk) || fatal "No initialized disk for persisting data found"
    boot_devpath=$(get_boot_devpath "$devpath")
    verbose "Mounting boot partition"
    mount "$boot_devpath" /boot
  elif $setup; then
    local devpaths=()
    devpath=$(get_node_config disk.devpath) || fatal "Unable to setup disk, no devpath provided in node-config.json"
    if "$PKGROOT/workloads/node/bin/resource-ready" disk &>/dev/null; then
      info "disk at '%s' is already setup" "$devpath"
    else
      if sfdisk -J "$devpath" 2>/dev/null || lsblk -Jndo FSTYPE "$devpath" | jq -re '.blockdevices[0].fstype != null' >/dev/null; then
        [[ $(get_node_config disk.force) = true ]] || fatal "Device %s is partitioned or contains a filesystem and .disk.force!=true, aborting disk setup" "$devpath"
      fi
      wipefs -a "$devpath"
      if lsblk -Jndo FSTYPE "$devpath" | jq -re '.blockdevices[0].fstype != null' &>/dev/null; then
        fatal "%s contains a filesystem, use \`wipefs -a\` to clear it first"
      fi

      sfdisk "$devpath" <<EOF
label: gpt
label-id: $DISK_UUID

size=1GiB, type=U, bootable, uuid=$ESP_UUID
uuid=$DATA_UUID
EOF
      boot_devpath=$(get_boot_devpath "$devpath")
      mkfs.vfat "$boot_devpath"
    fi
    set_node_state disk.devpath "$devpath"
  fi
}

main "$@"
