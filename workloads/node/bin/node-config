#!/usr/bin/env bash
# shellcheck source-path=../../..

set -Eeo pipefail; shopt -s inherit_errexit
PKGROOT=$(realpath "$(dirname "$(realpath "${BASH_SOURCE[0]}")")/../../..")
export LC_ALL=C

main() {
  source "$PKGROOT/.upkg/records.sh/records.sh"
  source "$PKGROOT/workloads/node/bootstrap/assets/etc/initramfs-tools/scripts/node-state.sh"
  source "$PKGROOT/.upkg/path-tools/path-tools.sh"
  PATH=$(path_prepend "$PKGROOT/.upkg/.bin")
  source "$PKGROOT/lib/options.sh"
  DOC="node-config - Manage the node configs
Usage:
  node-config
"
# docopt parser below, refresh this parser with `docopt.sh node-config`
# shellcheck disable=2016,2086,2317,1090,1091,2034
docopt() { local v='2.0.1'; source \
"$PKGROOT/.upkg/docopt-lib-v$v/docopt-lib.sh" "$v" || { ret=$?;printf -- "exit \
%d\n" "$ret";exit "$ret";};set -e;trimmed_doc=${DOC:0:58};usage=${DOC:38:20}
digest=72777;options=();node_0(){ return 0;};cat <<<' docopt_exit() { [[ -n $1 \
]] && printf "%s\n" "$1" >&2;printf "%s\n" "${DOC:38:20}" >&2;exit 1;}';local \
varnames=() varname;for varname in "${varnames[@]}"; do unset "var_$varname"
done;parse 0 "$@";return 0;local p=${DOCOPT_PREFIX:-''};for varname in \
"${varnames[@]}"; do unset "$p$varname";done;eval ;local docopt_i=1;[[ \
$BASH_VERSION =~ ^4.3 ]] && docopt_i=2;for ((;docopt_i>0;docopt_i--)); do for \
varname in "${varnames[@]}"; do declare -p "$p$varname";done;done;}
# docopt parser above, complete command for generating this parser is `docopt.sh --library='"$PKGROOT/.upkg/docopt-lib-v$v/docopt-lib.sh"' node-config`
  eval "$(docopt "$@")"

  local node_state_path node_opts=() node_config_state node_config_path node_display_name
  for node_state_path in "$PKGROOT/startup/boot-server/registry/node-state"/*; do
    node_config_state=configured
    node_config_path=$PKGROOT/startup/boot-server/registry/node-config/$(basename "$node_state_path")
    if ! node_display_name="$(jq -re '.hostname // empty' "$node_config_path") (configured)"; then
      node_display_name=$(jq -r --arg node_config_state "$node_config_state" '"(\(.variant)) \(.["primary-mac"]) (\($node_config_state))"' "$node_state_path")
    fi
    [[ -e $PKGROOT/startup/boot-server/registry/node-config/$(basename "$node_state_path") ]] || node_config_state=unconfigured
    node_opts+=("$node_state_path" "$node_display_name")
  done
  node_state_path=$(select_options "Select node to configure:" "" "${node_opts[@]}") \
    || fatal "No nodes found"

  local node_config_path node_config={} node_mac
  node_mac=$(jq -r '.["primary-mac"]' "$node_state_path")
  node_config_path=$PKGROOT/startup/boot-server/registry/node-config/$(basename "$node_state_path")
  [[ ! -e $node_config_path ]] || node_config=$(cat "$node_config_path")

  local node_labels=(node-role.kubernetes.io/control-plane)

  while true; do

    while true; do
      if hostname=$(jq -re '.hostname // empty' <<<"$node_config"); then
        out "Enter a hostname for the node [%s]: " "$hostname"
        hostname=$(get_text "$hostname")
      else
        out "Enter a hostname for the node: "
        hostname=$(get_text)
      fi
      node_config=$(jq --arg hostname "$hostname" '.hostname=$hostname' <<<"$node_config")

      local node_label node_label_opts=() node_label_state
      for node_label in "${node_labels[@]}"; do
        node_label_state=' (selected)'
        jq -re --arg label "$node_label" '(.["node-label"] // []) | contains([$label])' <<<"$node_config" >/dev/null || node_label_state=''
        node_label_opts+=("$node_label" "${node_label}${node_label_state}")
      done
      node_label=$(select_options "Toggle any node labels you want to apply [0]:" "Done" "${node_label_opts[@]}")
      [[ -n $node_label ]] || break
      node_config=$(jq --arg label "$node_label" 'if (.["node-label"] // []) | contains([$label]) then .["node-label"] = (.["node-label"] | map(select(. != $label))) else .["node-label"] = (.["node-label"] // []) + [$label] end' <<<"$node_config")
    done

    local blockdev blockdev_json blockdev_opts=() blockdev_selected
    for blockdev_json in $(jq -rc '.blockdevices[]' "$node_state_path"); do
      blockdev_selected=true
      [[ $(jq -r '.devname' <<<"$blockdev_json") = $(jq -r '.disk.devname // empty' <<<"$node_config") ]] || blockdev_selected=false
      blockdev_opts+=("$blockdev_json" "$(jq -r --argjson selected "$blockdev_selected" \
        '"/dev/\(.devname): \(if .filesystem == null then if .partitions == null then "blank" else "partitioned" end else .filesystem end)\(if $selected then " (selected)" else "" end)"' <<<"$blockdev_json")")
    done
    if [[ ${#blockdev_opts[@]} -gt 0 ]]; then
      blockdev=$(select_options "Select boot- and datadisk:" "" "${blockdev_opts[@]}")
    else
      fatal "The node does not have any blockdevices."
    fi
    node_config=$(jq --argjson blockdev "$blockdev" '.disk.devname = $blockdev.devname' <<<"$node_config")
    if jq -re '.filesystem != null or .partitions != null' <<<"$blockdev" &>/dev/null; then
      warning "ATTENTION: You have selected a disk with an existing filesystem or partition. Doing this will wipe all data on that disk."
      out "Are you sure you want to continue? [yN] "
      yesno || fatal "User aborted operation"
      node_config=$(jq '.disk.force=true' <<<"$node_config")
    fi

    local \
      nic nic_json nic_opts nic_in_network nic_configured_as \
      network_name \
      addr_opts addr_setup addrs \
      addr_opts=(dhcp DHCP fixed 'Fixed IP(s)')
    while true; do
      nic_opts=()
      for nic_json in $(jq -rc '.nics[]' "$node_state_path"); do
        nic_in_network=$(jq -r --argjson nic "$nic_json" '[.networks | to_entries[] | select(.value | contains("Name=\($nic.ifname)")) | .key] | first' <<<"$node_config")
        if [[ -n $nic_in_network ]]; then
          nic_json=$(jq --arg network "$nic_in_network" '.network=$network' <<<"$nic_json")
          nic_configured_as="configured in $nic_in_network"
        else
          nic_configured_as=unconfigured
        fi
        nic_opts+=("$nic_json" "$(jq -r --arg config "$nic_configured_as" '"\(.ifname): \(.mac) (\($config))"' <<<"$nic_json")")
      done
      nic=$(select_options "Select network interface to configure [0]:" "Done" "${nic_opts[@]}")
      [[ -n $nic ]] || break
      if nic_in_network=$(jq -re '.network // empty' <<<"$nic_json"); then
        node_config=$(jq --arg name "$nic_in_network" 'del(.networks[$name])' <<<"$node_config")
        out "Enter a name for the network (e.g. primary, lan0, host) [%s]: " "$nic_in_network"
        network_name=$(get_text "$nic_in_network")
      else
        out "Enter a name for the network (e.g. primary, lan0, host): "
        network_name=$(get_text)
      fi
      addr_setup=$(select_options "Network interface setup:" "" "${addr_opts[@]}")
      case $addr_setup in
        dhcp)
          node_config=$(jq --arg name "$network_name" --argjson nic "$nic" '.networks[$name] = "[Match]
Name=\($nic.ifname)
[Network]
DHCP=yes
"' <<<"$node_config")
        ;;
        fixed)
          out "Enter a comma-separated list of IP's you would like to assign to this network interface:\n"
          read -r addrs
          node_config=$(jq --arg name "$network_name" --argjson nic "$nic" --arg addrs "$addrs" '.networks[$name] = "[Match]
Name=\($nic.ifname)
[Network]
\([$addrs | split(",")[] | "Address=\(.)"] | join("\n"))
"' <<<"$node_config")
        ;;
      esac
    done

    jq <<<"$node_config" >&2
    out "The node configuration now looks like the above, would you like to reconfigure (n) or save (y)? [yN]"
    ! yesno || break
  done
  info "Saving node configuration for %s" "$node_mac"
  printf "%s\n" "$node_config" >"$node_config_path"
}

get_text() {
  local default=$1
  while true; do
    read -r input
    [[ -z $input ]] || break
    if [[ -n $default ]]; then
      input=$default
      break
    else
      out "Invalid input"
    fi
  done
  printf "%s\n" "$input"
}

yesno() {
  local yesno
  read -r yesno
  if [[ $yesno =~ ^[Yy](es)?$ ]]; then
    return 0
  else
    return 1
  fi
}

out() {
  local tpl=$1
  shift
  # shellcheck disable=SC2059
  printf "$tpl" "$@" >&2
}

main "$@"
