#!/usr/bin/env bash
# shellcheck source-path=../../..

set -Eeo pipefail; shopt -s inherit_errexit
PKGROOT=$(realpath "$(dirname "$(realpath "${BASH_SOURCE[0]}")")/../../..")
export LC_ALL=C

main() {
  source "$PKGROOT/.upkg/records.sh/records.sh"
  source "$PKGROOT/workloads/node/bootstrap/assets/etc/initramfs-tools/scripts/node.sh"
  source "$PKGROOT/.upkg/path-tools/path-tools.sh"
  PATH=$(path_prepend "$PKGROOT/.upkg/.bin")
  source "$PKGROOT/lib/options.sh"
  DOC="node-config - Manage the node configs
Usage:
  node-config
"
# docopt parser below, refresh this parser with `docopt.sh node-config`
# shellcheck disable=2016,2086,2317,1090,1091,2034
docopt() { local v='2.0.1'; source \
"$PKGROOT/.upkg/docopt-lib-v$v/docopt-lib.sh" "$v" || { ret=$?;printf -- "exit \
%d\n" "$ret";exit "$ret";};set -e;trimmed_doc=${DOC:0:58};usage=${DOC:38:20}
digest=72777;options=();node_0(){ return 0;};cat <<<' docopt_exit() { [[ -n $1 \
]] && printf "%s\n" "$1" >&2;printf "%s\n" "${DOC:38:20}" >&2;exit 1;}';local \
varnames=() varname;for varname in "${varnames[@]}"; do unset "var_$varname"
done;parse 0 "$@";return 0;local p=${DOCOPT_PREFIX:-''};for varname in \
"${varnames[@]}"; do unset "$p$varname";done;eval ;local docopt_i=1;[[ \
$BASH_VERSION =~ ^4.3 ]] && docopt_i=2;for ((;docopt_i>0;docopt_i--)); do for \
varname in "${varnames[@]}"; do declare -p "$p$varname";done;done;}
# docopt parser above, complete command for generating this parser is `docopt.sh --library='"$PKGROOT/.upkg/docopt-lib-v$v/docopt-lib.sh"' node-config`
  eval "$(docopt "$@")"

  local node_state_path node_opts=() node_config_state node_config_path node_display_name
  for node_state_path in "$PKGROOT/startup/boot-server/registry/node-state"/*; do
    node_config_state=configured
    node_config_path=$PKGROOT/startup/boot-server/registry/node-config/$(basename "$node_state_path")
    if ! node_display_name="$(jq -re '.hostname // empty' "$node_config_path") (configured)"; then
      node_display_name=$(jq -r --arg node_config_state "$node_config_state" '"(\(.variant)) \(.["primary-mac"]) (\($node_config_state))"' "$node_state_path")
    fi
    [[ -e $PKGROOT/startup/boot-server/registry/node-config/$(basename "$node_state_path") ]] || node_config_state=unconfigured
    node_opts+=("$node_state_path" "$node_display_name")
  done
  node_state_path=$(select_options "Select node to configure:" "" "${node_opts[@]}") \
    || fatal "No nodes found"

  local node_config_path node_config={} node_mac
  node_mac=$(jq -r '.["primary-mac"]' "$node_state_path")
  node_config_path=$PKGROOT/startup/boot-server/registry/node-config/$(basename "$node_state_path")
  [[ ! -e $node_config_path ]] || node_config=$(cat "$node_config_path")

  local node_labels=(node-role.kubernetes.io/control-plane)

  while true; do

    if hostname=$(jq -re '.hostname // empty' <<<"$node_config"); then
      out "Enter a hostname for the node [%s]: " "$hostname"
      hostname=$(get_text "$hostname")
    else
      out "Enter a hostname for the node: "
      hostname=$(get_text)
    fi
    node_config=$(jq --arg hostname "$hostname" '.hostname=$hostname' <<<"$node_config")

    while true; do
      local node_label node_label_opts=() node_label_state
      for node_label in "${node_labels[@]}"; do
        node_label_state=' (selected)'
        jq -re --arg label "$node_label" '(.["node-label"] // []) | contains([$label])' <<<"$node_config" >/dev/null || node_label_state=''
        node_label_opts+=("$node_label" "${node_label}${node_label_state}")
      done
      node_label=$(select_options "Toggle any node labels you want to apply [0]:" "Done" "${node_label_opts[@]}")
      [[ -n $node_label ]] || break
      node_config=$(jq --arg label "$node_label" 'if (.["node-label"] // []) | contains([$label]) then .["node-label"] = (.["node-label"] | map(select(. != $label))) else .["node-label"] = (.["node-label"] // []) + [$label] end' <<<"$node_config")
    done

    while true; do
      local blockdev blockdev_json blockdev_opts=() blockdev_selected
      for blockdev_json in $(jq -rc '.blockdevices[]' "$node_state_path"); do
        blockdev_selected=true
        [[ $(jq -r '.devpath' <<<"$blockdev_json") = $(jq -r '.disk.devpath // empty' <<<"$node_config") ]] || blockdev_selected=false
        blockdev_opts+=("$blockdev_json" "$(jq -r --argjson selected "$blockdev_selected" \
          '"\(.devpath): \(if .filesystem == null then if .partitions == null then "blank" else "partitioned" end else .filesystem end)\(if $selected then " (selected)" else "" end)"' <<<"$blockdev_json")")
      done
      if [[ ${#blockdev_opts[@]} -gt 0 ]]; then
        blockdev=$(select_options "Select boot- and datadisk:" "Done" "${blockdev_opts[@]}")
      else
        fatal "The node does not have any blockdevices."
      fi
      if [[ -z $blockdev ]]; then
        [[ -z $(jq -r '.disk.devpath // empty' <<<"$node_config") ]] || break
        warning "You must select a disk"
        continue
      fi
      if jq -re '.filesystem != null or .partitions != null' <<<"$blockdev" &>/dev/null; then
        warning "ATTENTION: You have selected a disk with an existing filesystem or partition. Doing this will wipe all data on that disk."
        out "Are you sure you want to continue? [yN] "
        yesno n || continue
        node_config=$(jq '.disk.force=true' <<<"$node_config")
      else
        node_config=$(jq 'del(.disk.force)' <<<"$node_config")
      fi
      node_config=$(jq --argjson blockdev "$blockdev" '.disk.devpath = $blockdev.devpath' <<<"$node_config")
      break
    done

    local encrypt_disk
    while true; do
      encrypt_disk=$(jq -r '.disk.encrypted' <<<"$node_config")
      if [[ $encrypt_disk = null || $encrypt_disk = true ]]; then
        encrypt_disk=true
        out "Should the disk be encrypted? [Yn] "
      else
        out "Should the disk be encrypted? [yN] "
      fi
      if jq -re --argjson node_config "$node_config" '.disk.devpath != null and .disk.devpath == $node_config.disk.devpath' "$node_state_path" >/dev/null; then
        if jq -re '.disk.encrypted' "$node_state_path" >/dev/null; then
          encrypt_disk=true
          out "Yes (cannot change, disk is already initialized)\n"
        else
          encrypt_disk=false
          out "No (cannot change, disk is already initialized)\n"
        fi
      else
        if [[ $encrypt_disk != null ]]; then
          if yesno "$encrypt_disk"; then
            encrypt_disk=true
          else
            encrypt_disk=false
          fi
        else
          while true; do
            if ! yesno y; then
              warning "ATTENTION! Not encrypting your disk leaves all your data open to anyone with physical access to the node!"
              out "Are you sure you want to continue? [yN] "
              if yesno n; then
                encrypt_disk=false
              else
                continue 2
              fi
            fi
            break
          done
        fi
      fi
      break
    done
    node_config=$(jq --argjson encrypted "$encrypt_disk" '.disk.encrypted = $encrypted' <<<"$node_config")

    local \
      nic nic_json nic_opts nic_in_network nic_configured_as \
      network_name network_name_primary_taken \
      addr_opts addr_setup addrs \
      addr_opts=(fixed 'Fixed IP(s)')
    while true; do
      nic_opts=()
      network_name_primary_taken=false
      for nic_json in $(jq -rc '.nics[]' "$node_state_path"); do
        nic_in_network=$(jq -r --argjson nic "$nic_json" '[.networks // {} | to_entries[] | select(.value | contains("Name=\($nic.ifname)")) | .key] | first // empty' <<<"$node_config")
        if [[ -n $nic_in_network ]]; then
          nic_json=$(jq --arg network "$nic_in_network" '.network=$network' <<<"$nic_json")
          nic_configured_as="configured as '$nic_in_network'"
          [[ $nic_in_network != primary ]] || network_name_primary_taken=true
        else
          nic_configured_as=unconfigured
        fi
        nic_opts+=("$nic_json" "$(jq -r --arg config "$nic_configured_as" '"\(.ifname): \(.mac) (\($config))"' <<<"$nic_json")")
      done
      nic=$(select_options "Select network interface to configure [0]:" "Done" "${nic_opts[@]}")
      [[ -n $nic ]] || break
      if nic_in_network=$(jq -re '.network // empty' <<<"$nic_json"); then
        node_config=$(jq --arg name "$nic_in_network" 'del(.networks[$name])' <<<"$node_config")
        out "Enter a name for the network (e.g. primary, lan0, host) [%s]: " "$nic_in_network"
        network_name=$(get_text "$nic_in_network")
      elif $network_name_primary_taken; then
        out "Enter a name for the network (e.g. primary, lan0, host): "
        network_name=$(get_text)
      else
        out "Enter a name for the network (e.g. primary, lan0, host) [primary]: "
        network_name=$(get_text primary)
      fi
      addr_setup=$(select_options "Network interface setup:" "DHCP" "${addr_opts[@]}")
      case $addr_setup in
        "")
          node_config=$(jq --arg name "$network_name" --argjson nic "$nic" '.networks[$name] = "[Match]
Name=\($nic.ifname)
[Network]
DHCP=yes
"' <<<"$node_config")
        ;;
        fixed)
          out "Enter a comma-separated list of IP's you would like to assign to this network interface:\n"
          read -r addrs
          node_config=$(jq --arg name "$network_name" --argjson nic "$nic" --arg addrs "$addrs" '.networks[$name] = "[Match]
Name=\($nic.ifname)
[Network]
\([$addrs | split(",")[] | "Address=\(.)"] | join("\n"))
"' <<<"$node_config")
        ;;
      esac
    done

    jq <<<"$node_config" >&2
    out "The node configuration now looks like the above, would you like to reconfigure (n) or save (y)? [yN]"
    ! yesno n || break
  done
  info "Saving node configuration for %s" "$node_mac"
  printf "%s\n" "$node_config" >"$node_config_path"
}

get_text() {
  local default=$1
  while true; do
    read -r input
    [[ -z $input ]] || break
    if [[ -n $default ]]; then
      input=$default
      break
    else
      out "Invalid input"
    fi
  done
  printf "%s\n" "$input"
}

yesno() {
  local default=${1:-y} yesno
  read -r yesno
  while true; do
    if [[ $yesno =~ ^[Nn]o?$ ]]; then
      return 1
    elif [[ $yesno =~ ^[Yy](es)?$ ]]; then
      return 0
    elif [[ $yesno = '' ]]; then
      [[ $default = y || $default = true ]] || return 1
      return 0
    fi
    out "Invalid response"
  done
}

out() {
  local tpl=$1
  shift
  # shellcheck disable=SC2059
  printf "$tpl" "$@" >&2
}

main "$@"
