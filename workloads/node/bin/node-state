#!/usr/bin/env bash
# shellcheck source-path=../../..

set -Eeo pipefail; shopt -s inherit_errexit
PKGROOT=$(realpath "$(dirname "$(realpath "${BASH_SOURCE[0]}")")/../../..")
export LC_ALL=C

main() {
  source "$PKGROOT/.upkg/records.sh/records.sh"
  source "$PKGROOT/workloads/node/bootstrap/assets/etc/initramfs-tools/scripts/node-state.sh"
  DOC="node-state - Manage the node state
Usage:
  node-state report
  node-state collect
"
# docopt parser below, refresh this parser with `docopt.sh node-state`
# shellcheck disable=2016,2086,2317,1090,1091,2034
docopt() { local v='2.0.1'; source \
"$PKGROOT/.upkg/docopt-lib-v$v/docopt-lib.sh" "$v" || { ret=$?;printf -- "exit \
%d\n" "$ret";exit "$ret";};set -e;trimmed_doc=${DOC:0:82};usage=${DOC:35:47}
digest=33d35;options=();node_0(){ switch report a:report;};node_1(){ switch \
collect a:collect;};node_2(){ choice 0 1;};cat <<<' docopt_exit() { [[ -n $1 \
]] && printf "%s\n" "$1" >&2;printf "%s\n" "${DOC:35:47}" >&2;exit 1;}';local \
varnames=(report collect) varname;for varname in "${varnames[@]}"; do unset \
"var_$varname";done;parse 2 "$@";local p=${DOCOPT_PREFIX:-''};for varname in \
"${varnames[@]}"; do unset "$p$varname";done;eval $p'report=${var_report:-fals'\
'e};'$p'collect=${var_collect:-false};';local docopt_i=1;[[ $BASH_VERSION =~ \
^4.3 ]] && docopt_i=2;for ((;docopt_i>0;docopt_i--)); do for varname in \
"${varnames[@]}"; do declare -p "$p$varname";done;done;}
# docopt parser above, complete command for generating this parser is `docopt.sh --library='"$PKGROOT/.upkg/docopt-lib-v$v/docopt-lib.sh"' node-state`
  eval "$(docopt "$@")"

  # shellcheck disable=SC2154
  if $report; then
    local boot_server primary_mac node_state_addr
    boot_server=$(get_node_state boot-server) || fatal "Unable to report node state: boot-server not present in node-state.json"
    primary_mac=$(get_node_state primary-mac) || fatal "Unable to report node state: primary-mac not present in node-state.json"
    node_state_addr=https://${boot_server}:8021/node-state/${primary_mac//:/-}.json
    if curl -XPUT --cacert /usr/local/share/ca-certificates/home-cluster-root.crt -fL --no-progress-meter --connect-timeout 5 --retry 3 -d@$NODE_STATE "$node_state_addr" &>/dev/null; then
      info "The node state has been reported"
    else
      # shellcheck disable=SC2154
      fatal "Reporting the node state failed"
    fi
  elif $collect; then
    local blockdevices='[]' devname disk_filesystem disk_partitions
    for devname in $(lsblk --json --output NAME,FSTYPE,TYPE,MAJ:MIN | jq -r '.blockdevices[] | select(.type=="disk" and (.["maj:min"] | endswith(":0"))) | .name'); do
      disk_filesystem=$(lsblk -Jndo FSTYPE "/dev/$devname" | jq -re '.blockdevices[0].fstype')
      disk_partitions=$(sfdisk -J "/dev/$devname" 2>/dev/null || printf "null")
      blockdevices=$(jq --arg devname "$devname" --arg fs "$disk_filesystem" --argjson part "$disk_partitions" '. + [{"devname": $devname, "filesystem": $fs, "partitions": $part}]' <<<"$blockdevices")
    done
    set_node_state blockdevices "$blockdevices" true

    local nics
    nics=$(ip --json link show | jq '[.[] | select(.ifname != "lo") | {"ifname": .ifname, "mac": .address}]')
    set_node_state nics "$nics" true
  fi
}

main "$@"
