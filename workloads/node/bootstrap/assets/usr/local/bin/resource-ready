#!/usr/bin/env bash
set -Eeo pipefail; shopt -s inherit_errexit

main() {
  local e; for e; do [[ "$e" != "--help" ]] || usage; done
  local resource wait=false
  if [[ $1 = '--wait' ]]; then
    wait=true
    shift
  fi
  [[ $# -eq 1 ]] || usage
  resource=$1
  # shellcheck disable=SC2153
  local resource=${resource//[^A-Za-z0-9_]/_}
  type "${resource}_ready" &>/dev/null || { printf 'Unknown resource: "%s"\n' "$resource" >&2; return 1; }

  # shellcheck disable=SC2154
  if $wait; then
    until "${resource}_ready" &>/dev/null; do
      sleep 1
    done
    printf "%s is ready\n" "$resource" >&2
    return 0
  else
    if "${resource}_ready" &>/dev/null; then
      printf "%s is ready\n" "$resource" >&2
      return 0
    else
      printf "%s is not ready\n" "$resource" >&2
      return 1
    fi
  fi
}

k3s_ready() {
  kubectl get -n default endpoints kubernetes -ojsonpath='{.subsets[0].addresses}' | jq -e 'length > 0' &>/dev/null
}

cilium_ready() {
  _crd_installed ciliumbgppeeringpolicies.cilium.io
}

coredns_ready() {
  _deployment_ready kube-system coredns
}

cert_manager_ready() {
  _deployment_ready cert-manager cert-manager
}

longhorn_ready() {
  _deployment_ready longhorn-system csi-attacher || return 1
  _deployment_ready longhorn-system csi-provisioner || return 1
  _deployment_ready longhorn-system csi-resizer || return 1
  _deployment_ready longhorn-system csi-snapshotter || return 1
  _deployment_ready longhorn-system longhorn-driver-deployer || return 1
}

step_ca_bootstrap_ready() {
  _image_ready cluster.local/step-ca-bootstrap:latest
}

step_ca_ready() {
  _statefulset_ready smallstep step-ca
}

smallstep_ready() {
  _statefulset_ready smallstep step-ca || return 1
  _statefulset_ready smallstep kube-apiserver-client-ca || return 1
  _deployment_ready smallstep step-issuer || return 1
}

image_registry_ready() {
  _deployment_ready node image-registry
}

_crd_installed() {
  local crd=$1
  kubectl get crd "$crd" || return 1
}

_deployment_ready() {
  local ns=$1 deployment=$2
  [[ $(kubectl get -n "$ns" deployment "$deployment" -ojsonpath='{.status.readyReplicas}') -gt 0 ]] || return 1
}

_statefulset_ready() {
  local ns=$1 sts=$2
  [[ $(kubectl get -n "$ns" statefulset "$sts" -ojsonpath='{.status.readyReplicas}') -gt 0 ]] || return 1
}

_pod_ready() {
  local ns=$1 pod=$2
  kubectl -n "$ns" get pod "$pod" -o=jsonpath='{.status.conditions}' | jq -re 'any(.[] | select(.type == "Ready"); .status == "True")' >/dev/null
}

_namespace_ready() {
  local ns=$1
  [[ $(kubectl get namespace "$ns" -o jsonpath='{.status.phase}' 2>/dev/null) = 'Active' ]] || return 1
}

_image_ready() {
  local ref=$1
  ctr -n k8s.io image ls -q | grep -q "^$ref$" || return 1
}

usage() {
  printf "Usage:
  resource-ready [--wait] RESOURCE

Resources:
%s
" "$(compgen -A function | grep -P '^[^_].*_ready$' | sed 's/^/* /g' | sed 's/_ready//g' | sed 's/_/-/g')" >&2
  return 1
}

main "$@"
