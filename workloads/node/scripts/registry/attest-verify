#!/usr/bin/env bash
# shellcheck source-path=../../../..
set -Eeo pipefail; shopt -s inherit_errexit nullglob
PKGROOT=/usr/local/lib/upkg

main() {
  source "$PKGROOT/.upkg/records.sh/records.sh"
  DOC="attest-verify - Check an attested PCR quote
Usage:
  attest-verify EK_HASH PAYLOAD_DIR
"
# docopt parser below, refresh this parser with `docopt.sh attest-verify`
# shellcheck disable=2016,2086,2317,1090,1091,2034
docopt() { local v='2.0.2'; source \
"$PKGROOT/.upkg/docopt-lib-v$v/docopt-lib.sh" "$v" || { ret=$?;printf -- "exit \
%d\n" "$ret";exit "$ret";};set -e;trimmed_doc=${DOC:0:86};usage=${DOC:44:42}
digest=64b2f;options=();node_0(){ value EK_HASH a;};node_1(){ value \
PAYLOAD_DIR a;};node_2(){ sequence 0 1;};cat <<<' docopt_exit() { [[ -n $1 ]] \
&& printf "%s\n" "$1" >&2;printf "%s\n" "${DOC:44:42}" >&2;exit 1;}';local \
varnames=(EK_HASH PAYLOAD_DIR) varname;for varname in "${varnames[@]}"; do
unset "var_$varname";done;parse 2 "$@";local p=${DOCOPT_PREFIX:-''};for \
varname in "${varnames[@]}"; do unset "$p$varname";done;eval $p'EK_HASH=${var_'\
'EK_HASH:-};'$p'PAYLOAD_DIR=${var_PAYLOAD_DIR:-};';local docopt_i=1;[[ \
$BASH_VERSION =~ ^4.3 ]] && docopt_i=2;for ((;docopt_i>0;docopt_i--)); do for \
varname in "${varnames[@]}"; do declare -p "$p$varname";done;done;}
# docopt parser above, complete command for generating this parser is `docopt.sh --library='"$PKGROOT/.upkg/docopt-lib-v$v/docopt-lib.sh"' attest-verify`
  eval "$(docopt "$@")"

  LOGPROGRAM="attest-verify (${EK_HASH:0:8})"

  if ! is_ek_whitelisted "$EK_HASH"; then
    if is_ek_pending "$EK_HASH"; then
      fatal "The endorsement key is pending authorization"
    else
      add_pending_ek "$EK_HASH"
      fatal "The endorsement key is not whitelisted"
    fi
  else
    info "The endorsement key is whitelisted"
  fi

  local pcr4_sha256
  pcr4_sha256=$(yq -r '.pcrs.sha256["4"]' "$PAYLOAD_DIR/quote.yaml")
  # Lowercase with ",,"
  pcr4_sha256=${pcr4_sha256,,}
  if ! find_pcr4_match "$EK_HASH" "$pcr4_sha256"; then
    fatal "Unable to find match for PCR 4 amongst known or whitelisted images"
  fi

  info "Remote attestation succeeded"
  output_secrets

  return 0
}

find_pcr4_match() {
  # Lowercase with ",,"
  local EK_HASH=$1 pcr4_sha256=$2 digestfile
  verbose "Finding match for PCR 4 SHA256 %s" "$pcr4_sha256"
  for digestfile in /images/*/digests.json; do
    verbose "Checking against own image: %s" "$(basename "$(dirname "$digestfile")")"
    if check_pcr4_match "$digestfile" "$pcr4_sha256"; then
      info "SHA256 of PCR4 matches image at %s" "$digestfile"
      return 0
    fi
  done
  for digestfile in /attestation-database/pcr-whitelist/*; do
    verbose "Checking whitelisted digest: %s" "$(basename "$digestfile")"
    if check_pcr4_match "$digestfile" "$pcr4_sha256"; then
      info "SHA256 of PCR4 matches whitelist at %s" "$digestfile"
      return 0
    fi
  done
  return 1
}

sha256() {
  sha256sum | cut -d ' ' -f1
}

init_sha256=$(printf "0000000000000000000000000000000000000000000000000000000000000000")
start_sha256=$(printf "Calling EFI Application from Boot Option" | sha256)
barrier_sha256=$(printf "00000000" | xxd -r -p | sha256)
check_pcr4_match() {
  local digestfile=$1 pcr4_sha256=$2 shim_sha256 uki_sha256 kernel_sha256
  read -rd ' ' shim_sha256 uki_sha256 kernel_sha256 < <(jq -r '.shim.sha256, .uki.sha256, .kernel.sha256' "$digestfile")
  verbose "Checking against UKI SHA256: %s" "$uki_sha256"
  [[ $pcr4_sha256 != "$(sha256_extend "$init_sha256" "$start_sha256" "$barrier_sha256" "$shim_sha256" "$uki_sha256")" ]] || return 0
  [[ $pcr4_sha256 != "$(sha256_extend "$init_sha256" "$start_sha256" "$barrier_sha256" "$shim_sha256" "$uki_sha256" "$kernel_sha256")" ]] || return 0
  return 1
}

is_ek_whitelisted() {
  local EK_HASH=$1 ek_whitelist=/attestation-database/ek-whitelist.json
  if [[ -z $(cat "$ek_whitelist" 2>/dev/null) ]]; then
    printf '[]\n' >"$ek_whitelist"
  fi
  jq -re --arg ek_hash "$EK_HASH" 'index($ek_hash)!=null' "$ek_whitelist" &>/dev/null
}

is_ek_pending() {
  local EK_HASH=$1 ek_pending=/attestation-database/ek-pending.json
  jq -re --arg ek_hash "$EK_HASH" 'index($ek_hash)!=null' "$ek_pending" &>/dev/null
}

add_pending_ek() {
  local EK_HASH=$1 ek_pending=/attestation-database/ek-pending.json
  if [[ -z $(cat "$ek_pending" 2>/dev/null) ]]; then
    printf '[]\n' >"$ek_pending"
  fi
  local new_pending
  info "Adding to list of pending endorsement keys"
  new_pending=$(jq --arg ek_hash "$EK_HASH" '. += [$ek_hash]' "$ek_pending")
  printf "%s\n" "$new_pending" >"$ek_pending"
}

sha256_extend() {
  local next_sha256 result
  while [[ $# -gt 0 ]]; do
    next_sha256=$1
    shift
    if [[ -n $result ]]; then
      result=$( (xxd -r -p <<<"$result"; xxd -r -p <<<"$next_sha256") | sha256 )
    else
      result=$next_sha256
    fi
  done
  printf "%s" "$result"
}

output_secrets() {
  local disk_encryption_key k3s_token control_plane_addrs
  verbose "Outputting secrets"
  disk_encryption_key=$(cat /secrets/disk-encryption-key)
  k3s_token=$(cat /secrets/k3s-token)
  control_plane_addrs=$(
    kubectl get nodes -l "node-role.cluster.local/control-plane=true" \
      -o=jsonpath='{.items[*].status.addresses}' | jq -r '[.[] | select(.type=="InternalIP" and (.address | test("^[0-9.]+$"))) | "https://\(.address):6443"]'
  )
  jq -n --arg disk_encryption_key "$disk_encryption_key" --arg k3s_token "$k3s_token" --argjson control_plane_addrs "$control_plane_addrs" '{
    "disk-encryption-key": $disk_encryption_key,
    "k3s-token": $k3s_token,
    "control-plane-addrs": $control_plane_addrs
  }'
}

main "$@"
